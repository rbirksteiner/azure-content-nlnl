
<properties
   pageTitle="Azure Service Fabric Actor 具狀態服務的組合設計模式"
   description="Service Fabric Actor 設計模式使用具狀態的動作項目，以維護服務之間的呼叫和快取先前服務結果的狀態。狀態可以是持續性或暫時性。"
   services="service-fabric"
   documentationCenter=".net"
   authors="jessebenson"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="04/01/2015"
   ms.author="claudioc"/>

# Service Fabric Actor 設計模式：可設定狀態的服務組合
開發人員花費了最近 15 年建置在企業中多層式架構的無狀態服務。他們在資料庫上建置服務、在其他服務建置高序位服務，更建置協調流程引擎和訊息導向中介軟體以協調這些服務。當使用者工作負載擴大時，無論是要求更多的互動性或級別，無狀態服務導向架構開始曝露其缺點。

## 舊有方式：SOA 服務
雖然 SOA 服務基於其無狀態的本質，能順暢地進行水平調整，其卻建立了儲存層中並行處理和輸送量的瓶頸。存取儲存體也變得越來越昂貴。大部分開發人員的常見作法是引進快取，作為減少對儲存體需求的解決方案，但該方案不是沒有缺點，像是另一個需要管理的層、並行存取快取、語意的限制及變更，而最後還有一致性問題。如稍早在智慧快取模式中，虛擬動作項目模型為此提供完美的解決方案。

有些開發人員嘗試將複寫其儲存層以解決問題。不過，此方法並未妥善調整，並很快就達到 CAP 界限。第二個挑戰依瞬息萬變的需求而擴大；使用者和企業要求互動式服務，並以毫秒為單位，取代一般使用的秒來回應需求。若要回應，開發人員會開始在其他服務上建置服務的外觀機制，在某些情況下需要服務的 10 秒來建立以使用者為中心的服務。不過撰寫多個下游服務很快曝露出延遲問題。

同樣地，開發人員轉向快取和記憶體中的物件存放區，在某些情況下，以不同實作符合效能需求。他們開始建置後端背景工作處理序，以定期建立快取來減少昂貴的隨選快取擴展。最後，他們開始解構他們的工作負載，將非同步項目與同步項目隔離，以為回應變更狀態的互動式作業取得更多空間，這在 SOA 中尤其困難。

他們進一步介紹如佇列和背景工作的層，讓解決方案更為複雜。基本上，開發人員開始尋求能夠建置「具狀態服務」的解決方案，換句話說，共置「狀態」和「服務行為」來解決以使用者為中心的互動式體驗。而這就是 Azure Service Fabric Actor 作為服務組合層進場的時候，而非用於取代這些服務項目。

下圖將說明這一點：

![][1]

## 動作項目是更好的解決方案
在撰寫服務的情況下，動作項目可以是無狀態或具狀態。

* 無狀態的動作項目可以做為基礎服務的 Proxy。這些動作項目可以動態調整 Azure Service Fabric 叢集，並能夠快取相關特定資訊，例如發現的端點。
* 具狀態的動作項目可以維護服務之間的呼叫，以及快取先前服務結果的狀態。狀態可以是持續性或暫時性。

此模式也適用於許多情況下；大部分情況下，動作項目需要進行外部呼叫以叫用特定服務上的作業。讓我們使用現代電子商務應用程式的範例來說明。這些應用程式會根據所提供的各種功能在服務上建立，例如使用者設定檔管理、建議、購物籃管理、願望清單管理、購買及更多。

大部分的開發人員想要將以使用者為中心的方法帶進架構，非常類似開發共享體驗，因為電子商務體驗主要是圍繞使用者和產品。基於效能原因，這通常是由傳送快取最有可能支援的服務外觀機制來達成。

現在讓我們聊聊以動作項目為基礎的方法。使用者動作項目可以代表使用者的行為 (瀏覽目錄、對產品按讚、將項目加入購物籃、推薦產品給朋友)，及其組成的狀態，使用者的設定檔、購物籃中的物品、朋友推薦的產品、購買歷程記錄、目前地區位置及其他項目。

## 具狀態的動作項目
首先，讓我們看看一個使用者動作項目需要從多個服務填入其狀態的範例。我們不會為此項目提供程式碼範例，因為所有我們在智慧快取模式討論過的項目，也適用於此處。我們可以在登入時啟動使用者動作項目，從後端服務中填入足夠的資料。當然，我們稍早在本文中已經看過許多情況，全部及部分狀態可以預先填入隨選、計時器、或兩者的一部分，並在動作項目中快取。這個範例中，「設定檔」和「願望清單」如下圖所示：

![][2]

例如，我們可以預先填入常見的使用者狀態，並為每個月瀏覽服務的使用者在登入時準備好將其登入或填入。我們在＜智慧快取＞一節中看過這些模式。

當使用者 23 登入，如果尚未啟動，使用者動作項目 (23) 將會啟動，並從後端服務擷取相關的使用者設定檔資訊和願望清單。使用者動作項目很可能會快取資訊以進行後續呼叫。而如果我們需要將新增項目至願望清單，如先前所述，我們可以使用事後寫入或貫穿式寫入。再來，我們來看看當使用者按一下 [讚] 按鈕以對產品按讚的範例。這個動作可能需要多個服務的多個引動過程，如下所示：將「讚」傳送至目錄服務、觸發下一組建議，並或許在社交網路上張貼更新。

其程式碼如下所示：

![][3]

## 動作項目組合和非同步通訊將如何協助
事實上，當我們要一起撰寫非同步作業的要求/回應樣式作業，Azure Service Fabric Actor 即會發揮功效。例如，雖然「對產品按讚」會立即將按讚的項目放入使用者的願望清單中、張貼到社交網路上，並觸發下一組建議，可以使用緩衝處理和計時器變成非同步作業。

另一個使用使用者動作項目和服務的主要優點是，動作項目會提供已快取的狀態一個自然的地方，而最重要的是，會以非同步方式回應其狀態的變更。這是無狀態服務非常棘手的狀況。例如，使用者執行一系列的動作，或許是「使用者旅程」的一部分。 動作項目可以即時擷取這些事件，而我們就可以組合資料流，在事件發生時間進行查詢，或在計時器上以非同步方式變更執行者的行為。

此時 SOA 純化論者肯定注意到這些不是動作項目的服務，因為端點是透過獨立語言的通訊協定公開。Azure Service Fabric Actor 並非互通的元件或服務交互操作的平台。不過，其實沒有什麼東西阻止我們以 SOA 樣式服務的資料粒度方式思考，並以相同的方式模組化我們的動作項目或模組化個別考量。這種服務稱為「微服務」。 同樣地，完全沒有任何東西阻止我們將 REST 端點或 SOAP 端點作為 Interop 層放在 Azure Service Fabric Actor 的前面。

具狀態服務的組合也適用於工作流程，並不限於如電子商務的交易式案例。Azure Service Fabric 是設計為工作流程/協調流程引擎，因此可以用來模組化涉及服務互動的工作流程，和維護這些互動的狀態。

我們可以從建置可延展的服務以提供動態體驗中，看到「無狀態服務」的缺點。Azure Service Fabric Actor 基本上是透過結合狀態和行為，以協助開發人員在現有的投資上建置可調整及互動的體驗。


## 後續步驟
[模式：智慧型快取](service-fabric-reliable-actors-pattern-smart-cache.md)

[模式：分散式網路和圖形](service-fabric-reliable-actors-pattern-distributed-networks-and-graphs.md)

[模式：資源管理](service-fabric-reliable-actors-pattern-resource-governance.md)

[模式：物聯網](service-fabric-reliable-actors-pattern-internet-of-things.md)

[模式：分散式計算](service-fabric-reliable-actors-pattern-distributed-computation.md)

[某些反向模式](service-fabric-reliable-actors-anti-patterns.md)

[Service Fabric Actor 簡介](service-fabric-reliable-actors-introduction.md)


<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-1.png
[2]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-2.png
[3]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-3.png
 

<!---HONumber=July15_HO2-->